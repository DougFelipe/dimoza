// Problema 6 - Implementação REAL de BST com Structs
// Algoritmos completos de inserção, busca e traversal

// Definição da estrutura do nó da BST
struct TreeNode {
    Int key;
    TreeNode left;
    TreeNode right;  
};

// Função de inserção recursiva na BST
TreeNode insert(TreeNode root, Int value) {
    if (root == null) {
        TreeNode new_node <- NEW TreeNode;
        new_node.key <- value;
        new_node.left <- null;
        new_node.right <- null;
        return new_node;
    }
    
    if (value < root.key) {
        root.left <- insert(root.left, value);
    }
    
    if (value > root.key) {
        root.right <- insert(root.right, value);
    }
    
    return root;
}

// Busca do mínimo (sempre à esquerda)
Unit find_min(TreeNode node, Int level) {
    if (node == null) {
        return;
    }
    
    if (node.left == null) {
        print_string "Chave minima encontrada:";
        print(node.key);
        print_string "Nivel:";
        print(level);
        return;
    }
    
    find_min(node.left, level + 1);
}

// Busca do máximo (sempre à direita)  
Unit find_max(TreeNode node, Int level) {
    if (node == null) {
        return;
    }
    
    if (node.right == null) {
        print_string "Chave maxima encontrada:";
        print(node.key);
        print_string "Nivel:";
        print(level);
        return;
    }
    
    find_max(node.right, level + 1);
}

// Função auxiliar para calcular altura da árvore
Int get_height(TreeNode node) {
    if (node == null) {
        return 0;
    }
    
    Int left_height <- get_height(node.left);
    Int right_height <- get_height(node.right);
    
    if (left_height > right_height) {
        return left_height + 1;
    }
    
    return right_height + 1;
}

// Imprime nós de um nível específico
Unit print_given_level(TreeNode root, Int level) {
    if (root == null) {
        return;
    }
    
    if (level == 1) {
        print_inline(root.key);
        return;
    }
    
    print_given_level(root.left, level - 1);
    print_given_level(root.right, level - 1);
}

// Impressão por níveis (level-order traversal)
Unit print_level_order(TreeNode root) {
    Int height <- get_height(root);
    Int i <- 1;
    
    while (i <= height) {
        print_string "--- Nivel";
        print(i);
        print_string "---";
        print_given_level(root, i);
        print_string "";
        i <- i + 1;
    }
}

// Função principal
Int main() {
    print_string "=== BST - Implementacao Real com Algoritmos Completos ===";
    print_string "";
    
    // A) Construir BST inserindo valores sequencialmente
    print_string "A) Construindo BST com algoritmo de insercao recursivo";
    
    TreeNode root <- null;
    
    print_string "Inserindo: 50, 30, 20, 40, 70, 60, 80";
    
    root <- insert(root, 50);
    root <- insert(root, 30);
    root <- insert(root, 20);
    root <- insert(root, 40);
    root <- insert(root, 70);
    root <- insert(root, 60);
    root <- insert(root, 80);
    
    print_string "BST construida com algoritmo recursivo real!";
    print_string "";
    
    // B) Buscar chave mínima
    print_string "B) Busca da chave minima (navegacao a esquerda):";
    find_min(root, 1);
    print_string "";
    
    // C) Buscar chave máxima
    print_string "C) Busca da chave maxima (navegacao a direita):";
    find_max(root, 1);
    print_string "";
    
    // D) Impressão por níveis
    print_string "D) Impressao da arvore nivel por nivel:";
    print_level_order(root);
    
    print_string "=== BST implementada com algoritmos reais! ===";
    
    return 0;
}
