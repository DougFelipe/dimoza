// PROBLEMA 6: √ÅRVORE BIN√ÅRIA DE BUSCA (BST) - VERS√ÉO EDUCACIONAL E INTERATIVA
// =================================================================
// M√ìDULO A: DEFINI√á√ÉO DA ESTRUTURA DA √ÅRVORE
// =================================================================

// Estrutura do n√≥ da √°rvore bin√°ria de busca
// Cada n√≥ cont√©m uma chave inteira e ponteiros para sub√°rvores esquerda e direita
struct TreeNode {
    Int key;           // Chave do n√≥ (valor inteiro)
    TreeNode left;     // Ponteiro para sub√°rvore esquerda
    TreeNode right;    // Ponteiro para sub√°rvore direita
};

// =================================================================
// M√ìDULO B: OPERA√á√ïES FUNDAMENTAIS DA BST
// =================================================================

// Fun√ß√£o de inser√ß√£o recursiva na √°rvore bin√°ria de busca
// Mant√©m a propriedade BST: esquerda < n√≥ < direita
// Retorna a raiz da √°rvore (possivelmente modificada)
TreeNode insert(TreeNode root, Int value) {
    // Caso base: √°rvore vazia - criar novo n√≥
    if (root == null) {
        TreeNode new_node <- NEW TreeNode;
        new_node.key <- value;
        new_node.left <- null;
        new_node.right <- null;
        print_string "   OK: N√≥ ";
        print value;
        print_string " inserido como nova raiz/folha";
        return new_node;
    }
    
    // Inser√ß√£o √† esquerda (valor menor)
    if (value < root.key) {
        print_string "   --> ";
        print value;
        print_string " < ";
        print root.key;
        print_string " ‚Üí inserindo √† esquerda";
        root.left <- insert(root.left, value);
    }
    
    // Inser√ß√£o √† direita (valor maior)
    if (value > root.key) {
        print_string "   --> ";
        print value;
        print_string " > ";
        print root.key;
        print_string " ‚Üí inserindo √† direita";
        root.right <- insert(root.right, value);
    }
    
    // Valor igual - n√£o inserir duplicatas
    if (value == root.key) {
        print_string "   AVISO: Valor ";
        print value;
        print_string " j√° existe - ignorando duplicata";
    }
    
    return root;
}

// =================================================================
// M√ìDULO C: OPERA√á√ïES DE BUSCA (M√çNIMO E M√ÅXIMO)
// =================================================================

// Busca da chave m√≠nima (sempre na sub√°rvore esquerda)
// Navega recursivamente √† esquerda at√© encontrar folha
Unit find_min(TreeNode node, Int level) {
    if (node == null) {
        print_string "‚ùå √Årvore vazia - sem valor m√≠nimo";
        return;
    }
    
    print_string "BUSCA: N√≠vel ";
    print level;
    print_string ": examinando n√≥ ";
    print node.key;
    
    // Caso base: n√£o h√° mais n√≥s √† esquerda
    if (node.left == null) {
        print_string "";
        print_string "ENCONTRADO: CHAVE M√çNIMA ENCONTRADA:";
        print_string "   Valor: ";
        print node.key;
        print_string "   N√≠vel: ";
        print level;
        print_string "   (Extremo esquerdo da √°rvore)";
        return;
    }
    
    print_string " ‚Üí continuando √† esquerda";
    find_min(node.left, level + 1);
}

// Busca da chave m√°xima (sempre na sub√°rvore direita)
// Navega recursivamente √† direita at√© encontrar folha
Unit find_max(TreeNode node, Int level) {
    if (node == null) {
        print_string "‚ùå √Årvore vazia - sem valor m√°ximo";
        return;
    }
    
    print_string "BUSCA: N√≠vel ";
    print level;
    print_string ": examinando n√≥ ";
    print node.key;
    
    // Caso base: n√£o h√° mais n√≥s √† direita
    if (node.right == null) {
        print_string "";
        print_string "ENCONTRADO: CHAVE M√ÅXIMA ENCONTRADA:";
        print_string "   Valor: ";
        print node.key;
        print_string "   N√≠vel: ";
        print level;
        print_string "   (Extremo direito da √°rvore)";
        return;
    }
    
    print_string " ‚Üí continuando √† direita";
    find_max(node.right, level + 1);
}

// =================================================================
// M√ìDULO D: OPERA√á√ïES DE IMPRESS√ÉO E VISUALIZA√á√ÉO
// =================================================================

// Fun√ß√£o auxiliar para calcular a altura da √°rvore
// Altura = m√°ximo caminho da raiz at√© uma folha
Int get_height(TreeNode node) {
    if (node == null) {
        return 0;
    }
    
    Int left_height <- get_height(node.left);
    Int right_height <- get_height(node.right);
    
    if (left_height > right_height) {
        return left_height + 1;
    }
    
    return right_height + 1;
}

// Imprime um n√≥ individual na visualiza√ß√£o da √°rvore
// Inclui representa√ß√£o de n√≥s nulos para manter estrutura visual
Unit print_single_node(TreeNode node, Int width) {
    if (node == null) {
        // Representa n√≥ ausente com '---'
        Int i1 <- 1;
        while (i1 <= (width - 3) / 2) {
            print_string " ";
            i1 <- i1 + 1;
        }
        print_string "---";
        Int j1 <- 1;
        while (j1 <= (width - 3) / 2) {
            print_string " ";
            j1 <- j1 + 1;
        }
    }
    
    if (node != null) {
        // Centraliza o valor do n√≥ dentro da largura dispon√≠vel
        Int value_len <- 3; // Assume n√∫meros de at√© 3 d√≠gitos
        Int padding <- (width - value_len) / 2;
        
        Int i2 <- 1;
        while (i2 <= padding) {
            print_string " ";
            i2 <- i2 + 1;
        }
        
        if (node.key < 10) {
            print_string " ";
        }
        if (node.key < 100) {
            print_string " ";
        }
        print node.key;
        
        Int j2 <- 1;
        while (j2 <= padding) {
            print_string " ";
            j2 <- j2 + 1;
        }
    }
}

// Imprime uma linha de conex√µes visuais entre n√≠veis
Unit print_connections(Int level, Int max_height, Int nodes_in_level) {
    Int total_width <- 80; // Largura total da visualiza√ß√£o
    Int node_width <- total_width / nodes_in_level;
    
    if (level >= max_height) {
        return; // N√£o h√° conex√µes ap√≥s o √∫ltimo n√≠vel
    }
    
    // Imprime linha com '/' e '\' para mostrar conex√µes pai-filho
    Int i <- 1;
    while (i <= nodes_in_level) {
        Int center <- (i - 1) * node_width + node_width / 2;
        Int left_child <- center - node_width / 4;
        Int right_child <- center + node_width / 4;
        
        // Imprime espa√ßos at√© a posi√ß√£o da conex√£o esquerda
        Int spaces_before_left <- left_child - ((i - 1) * node_width);
        Int j <- 1;
        while (j <= spaces_before_left) {
            print_string " ";
            j <- j + 1;
        }
        
        print_string "/";
        
        // Imprime espa√ßos entre conex√µes
        Int spaces_between <- right_child - left_child - 1;
        Int k <- 1;
        while (k <= spaces_between) {
            print_string " ";
            k <- k + 1;
        }
        
        print_string "\\";
        
        i <- i + 1;
    }
    print_string "";
}

// Coleta todos os n√≥s de um n√≠vel espec√≠fico em uma lista conceitual
// Para impress√£o organizada da estrutura visual
Unit print_level_nodes(TreeNode root, Int level, Int nodes_printed, Int total_nodes) {
    if (level == 1) {
        print_single_node(root, 80 / total_nodes);
        return;
    }
    
    if (root != null) {
        print_level_nodes(root.left, level - 1, nodes_printed, total_nodes);
        print_level_nodes(root.right, level - 1, nodes_printed, total_nodes);
    }
    
    if (root == null) {
        // Para n√≥s nulos, ainda precisamos imprimir espa√ßos para filhos
        if (level > 1) {
            print_level_nodes(null, level - 1, nodes_printed, total_nodes);
            print_level_nodes(null, level - 1, nodes_printed, total_nodes);
        }
    }
}

// Fun√ß√£o auxiliar para impress√£o visual simplificada de um n√≠vel
Unit print_level_visual(TreeNode root, Int target_level, Int spacing) {
    if (target_level == 1) {
        if (root != null) {
            print_string "[";
            print root.key;
            print_string "]";
        }
        
        if (root == null) {
            print_string " --- ";
        }
        
        // Adiciona espa√ßamento entre n√≥s do mesmo n√≠vel
        Int espacos <- 1;
        while (espacos <= spacing) {
            print_string " ";
            espacos <- espacos + 1;
        }
        return;
    }
    
    if (root != null) {
        print_level_visual(root.left, target_level - 1, spacing);
        print_level_visual(root.right, target_level - 1, spacing);
    }
    
    if (root == null) {
        // Para n√≥s nulos, ainda processamos os "filhos" conceituais
        print_level_visual(null, target_level - 1, spacing);
        print_level_visual(null, target_level - 1, spacing);
    }
}

// Fun√ß√£o auxiliar para imprimir conex√µes simples entre n√≠veis
Unit print_connections_simple(TreeNode root, Int target_level, Int spacing) {
    if (target_level == 1) {
        if (root != null) {
            // Imprime conex√µes do n√≥ atual para seus filhos
            Int tem_filhos <- 0;
            if (root.left != null) {
                tem_filhos <- 1;
            }
            if (root.right != null) {
                tem_filhos <- 1;
            }
            
            if (tem_filhos == 1) {
                if (root.left != null) {
                    print_string "/";
                }
                
                if (root.left == null) {
                    print_string " ";
                }
                
                print_string "   ";
                
                if (root.right != null) {
                    print_string "\\";
                }
                
                if (root.right == null) {
                    print_string " ";
                }
            }
            
            if (tem_filhos == 0) {
                print_string "     "; // Espa√ßo para n√≥ sem filhos
            }
        }
        
        // Espa√ßamento entre grupos de conex√µes
        Int espacos2 <- 1;
        while (espacos2 <= spacing) {
            print_string " ";
            espacos2 <- espacos2 + 1;
        }
        return;
    }
    
    if (root != null) {
        if (target_level > 1) {
            print_connections_simple(root.left, target_level - 1, spacing);
            print_connections_simple(root.right, target_level - 1, spacing);
        }
    }
    
    if (root == null) {
        if (target_level > 1) {
            // Para n√≥s nulos, ainda processamos os "filhos" conceituais
            print_connections_simple(null, target_level - 1, spacing);
            print_connections_simple(null, target_level - 1, spacing);
        }
    }
}

// Impress√£o visual avan√ßada da √°rvore (representa√ß√£o hier√°rquica melhorada)
// Cria uma visualiza√ß√£o mais intuitiva da estrutura da BST no console
// Mostra conex√µes entre n√≠veis e alinhamento hier√°rquico claro
Unit print_level_order(TreeNode root) {
    if (root == null) {
        print_string "ERRO: √Årvore vazia - nada para imprimir";
        return;
    }
    
    Int height <- get_height(root);
    
    print_string "VISUALIZA√á√ÉO HIER√ÅRQUICA DA BST";
    print_string "===============================================";
    print_string "   Altura da √°rvore: ";
    print height;
    print_string " n√≠veis";
    print_string "";
    print_string "   Legenda: [valor] = n√≥ existente - --- = n√≥ ausente";
    print_string "            /\\ = conex√µes pai-filho";
    print_string "";
    
    // Vers√£o simplificada: impress√£o n√≠vel por n√≠vel com espa√ßamento visual
    Int level <- 1;
    while (level <= height) {
        // Calcula espa√ßamento para centralizar cada n√≠vel
        Int spaces_before <- (height - level) * 6;
        Int spaces_between <- (level - 1) * 4 + 8;
        
        // Linha indicadora do n√≠vel
        print_string "N√≠vel ";
        print level;
        print_string ": ";
        
        // Espa√ßamento inicial para centralizar
        Int espacamento <- 1;
        while (espacamento <= spaces_before) {
            print_string " ";
            espacamento <- espacamento + 1;
        }
        
        // Imprime os n√≥s deste n√≠vel
        print_level_visual(root, level, spaces_between);
        print_string "";
        
        // Imprime linha de conex√µes (exceto para o √∫ltimo n√≠vel)
        if (level < height) {
            print_string "        "; // Alinha com "N√≠vel X: "
            Int espacamento2 <- 1;
            while (espacamento2 <= spaces_before - 2) {
                print_string " ";
                espacamento2 <- espacamento2 + 1;
            }
            print_connections_simple(root, level, spaces_between);
            print_string "";
        }
        
        level <- level + 1;
    }
    
    print_string "";
    print_string "===============================================";
    print_string "OK: Visualiza√ß√£o hier√°rquica da BST finalizada";
    print_string "";
    print_string "INTERPRETA√á√ÉO DA ESTRUTURA:";
    print_string "   ‚Ä¢ Cada n√≠vel mostra os n√≥s na mesma profundidade";
    print_string "   ‚Ä¢ N√≥s centralizados mostram a hierarquia visual";
    print_string "   ‚Ä¢ Conex√µes /\\ indicam rela√ß√µes pai-filho";
    print_string "   ‚Ä¢ Sub√°rvore esquerda fica √† esquerda do pai";
    print_string "   ‚Ä¢ Sub√°rvore direita fica √† direita do pai";
}

// =================================================================
// PROGRAMA PRINCIPAL - DEMONSTRA√á√ÉO INTERATIVA
// =================================================================

Int main() {
    // =============================================================
    // CABE√áALHO E APRESENTA√á√ÉO DO PROGRAMA
    // =============================================================
    
    print_string "==================================================================";
    print_string "         √ÅRVORE BIN√ÅRIA DE BUSCA (BST) - LINGUAGEM DIMOZA";
    print_string "==================================================================";
    print_string "";
    
    // =============================================================
    // OPERA√á√ÉO A: CONSTRU√á√ÉO DA BST COM ENTRADA INTERATIVA
    // =============================================================
    
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "                  OPERA√á√ÉO A: CONSTRU√á√ÉO DA BST";
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "";
    
    TreeNode root <- null;
    Int quantidade;
    Int i;
    
    print_string "üî¢ Digite a quantidade de valores a inserir na BST:";
    Float entrada_qtd <- read();
    quantidade <- entrada_qtd;
    
    if (quantidade <= 0) {
        print_string "‚ùå ERRO: Quantidade deve ser positiva!";
        print_string "Programa encerrado.";
        return 1;
    }
    
    print_string "";
    print_string "üìù Digite os ";
    print quantidade;
    print_string " valores inteiros (um por linha):";
    print_string "";
    
    i <- 1;
    while (i <= quantidade) {
        print_string "üî¢ Valor ";
        print i;
        print_string ": ";
        Float entrada_valor <- read();
        Int valor <- entrada_valor;
        
        print_string "üå± Inserindo ";
        print valor;
        print_string " na BST...";
        root <- insert(root, valor);
        print_string "";
        
        i <- i + 1;
    }
    
    print_string "OK: BST constru√≠da com sucesso!";
    print_string "";
    
    // =============================================================
    // OPERA√á√ÉO B: BUSCA DA CHAVE M√çNIMA
    // =============================================================
    
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "                  OPERA√á√ÉO B: BUSCA DA CHAVE M√çNIMA";
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "";
    print_string "üîç Buscando a chave m√≠nima (navega√ß√£o √† esquerda)...";
    print_string "";
    
    find_min(root, 1);
    print_string "";
    
    // =============================================================
    // OPERA√á√ÉO C: BUSCA DA CHAVE M√ÅXIMA
    // =============================================================
    
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "                  OPERA√á√ÉO C: BUSCA DA CHAVE M√ÅXIMA";
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "";
    print_string "üîç Buscando a chave m√°xima (navega√ß√£o √† direita)...";
    print_string "";
    
    find_max(root, 1);
    print_string "";
    
    // =============================================================
    // OPERA√á√ÉO D: IMPRESS√ÉO DA √ÅRVORE POR N√çVEIS
    // =============================================================
    
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "                  OPERA√á√ÉO D: VISUALIZA√á√ÉO DA BST";
    print_string "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
    print_string "";
    print_string "üå≥ Imprimindo √°rvore bin√°ria de busca por n√≠veis...";
    print_string "";
    
    print_level_order(root);
    print_string "";
    
    // =============================================================
    // FINALIZA√á√ÉO DO PROGRAMA
    // =============================================================
    
    print_string "==================================================================";
    print_string "                      PROGRAMA FINALIZADO";
    print_string "==================================================================";
    print_string "";
    print_string "OK: Todas as opera√ß√µes da BST foram executadas com sucesso!";

    
    return 0;
}
